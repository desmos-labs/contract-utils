/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.21.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { Uint64, Uint128, InstantiateMsg, InstantiateMsg1, Rarity, Coin, ExecuteMsg, QueryMsg, Expiration, Timestamp, AllNftInfoResponseForMetadata, OwnerOfResponse, Approval, NftInfoResponseForMetadata, Metadata, Addr, QueryConfigResponse, QueryRaritiesResponse, TokensResponse } from "./Remarkables.types";
import { RemarkablesQueryClient, RemarkablesClient } from "./Remarkables.client";
export const remarkablesQueryKeys = {
  contract: ([{
    contract: "remarkables"
  }] as const),
  address: (contractAddress: string | undefined) => ([{ ...remarkablesQueryKeys.contract[0],
    address: contractAddress
  }] as const),
  config: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...remarkablesQueryKeys.address(contractAddress)[0],
    method: "config",
    args
  }] as const),
  rarities: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...remarkablesQueryKeys.address(contractAddress)[0],
    method: "rarities",
    args
  }] as const),
  allNftInfo: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...remarkablesQueryKeys.address(contractAddress)[0],
    method: "all_nft_info",
    args
  }] as const),
  tokens: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...remarkablesQueryKeys.address(contractAddress)[0],
    method: "tokens",
    args
  }] as const)
};
export const remarkablesQueries = {
  config: <TData = QueryConfigResponse,>({
    client,
    options
  }: RemarkablesConfigQuery<TData>): UseQueryOptions<QueryConfigResponse, Error, TData> => ({
    queryKey: remarkablesQueryKeys.config(client?.contractAddress),
    queryFn: () => client ? client.config() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  rarities: <TData = QueryRaritiesResponse,>({
    client,
    options
  }: RemarkablesRaritiesQuery<TData>): UseQueryOptions<QueryRaritiesResponse, Error, TData> => ({
    queryKey: remarkablesQueryKeys.rarities(client?.contractAddress),
    queryFn: () => client ? client.rarities() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  allNftInfo: <TData = AllNftInfoResponseForMetadata,>({
    client,
    args,
    options
  }: RemarkablesAllNftInfoQuery<TData>): UseQueryOptions<AllNftInfoResponseForMetadata, Error, TData> => ({
    queryKey: remarkablesQueryKeys.allNftInfo(client?.contractAddress, args),
    queryFn: () => client ? client.allNftInfo({
      includeExpired: args.includeExpired,
      tokenId: args.tokenId
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  tokens: <TData = TokensResponse,>({
    client,
    args,
    options
  }: RemarkablesTokensQuery<TData>): UseQueryOptions<TokensResponse, Error, TData> => ({
    queryKey: remarkablesQueryKeys.tokens(client?.contractAddress, args),
    queryFn: () => client ? client.tokens({
      limit: args.limit,
      owner: args.owner,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  })
};
export interface RemarkablesReactQuery<TResponse, TData = TResponse> {
  client: RemarkablesQueryClient | undefined;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface RemarkablesTokensQuery<TData> extends RemarkablesReactQuery<TokensResponse, TData> {
  args: {
    limit?: number;
    owner: string;
    startAfter?: string;
  };
}
export function useRemarkablesTokensQuery<TData = TokensResponse>({
  client,
  args,
  options
}: RemarkablesTokensQuery<TData>) {
  return useQuery<TokensResponse, Error, TData>(remarkablesQueryKeys.tokens(client?.contractAddress, args), () => client ? client.tokens({
    limit: args.limit,
    owner: args.owner,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface RemarkablesAllNftInfoQuery<TData> extends RemarkablesReactQuery<AllNftInfoResponseForMetadata, TData> {
  args: {
    includeExpired?: boolean;
    tokenId: string;
  };
}
export function useRemarkablesAllNftInfoQuery<TData = AllNftInfoResponseForMetadata>({
  client,
  args,
  options
}: RemarkablesAllNftInfoQuery<TData>) {
  return useQuery<AllNftInfoResponseForMetadata, Error, TData>(remarkablesQueryKeys.allNftInfo(client?.contractAddress, args), () => client ? client.allNftInfo({
    includeExpired: args.includeExpired,
    tokenId: args.tokenId
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface RemarkablesRaritiesQuery<TData> extends RemarkablesReactQuery<QueryRaritiesResponse, TData> {}
export function useRemarkablesRaritiesQuery<TData = QueryRaritiesResponse>({
  client,
  options
}: RemarkablesRaritiesQuery<TData>) {
  return useQuery<QueryRaritiesResponse, Error, TData>(remarkablesQueryKeys.rarities(client?.contractAddress), () => client ? client.rarities() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface RemarkablesConfigQuery<TData> extends RemarkablesReactQuery<QueryConfigResponse, TData> {}
export function useRemarkablesConfigQuery<TData = QueryConfigResponse>({
  client,
  options
}: RemarkablesConfigQuery<TData>) {
  return useQuery<QueryConfigResponse, Error, TData>(remarkablesQueryKeys.config(client?.contractAddress), () => client ? client.config() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface RemarkablesClaimFeesMutation {
  client: RemarkablesClient;
  msg: {
    receiver: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useRemarkablesClaimFeesMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, RemarkablesClaimFeesMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, RemarkablesClaimFeesMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.claimFees(msg, fee, memo, funds), options);
}
export interface RemarkablesUpdateAdminMutation {
  client: RemarkablesClient;
  msg: {
    newAdmin: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useRemarkablesUpdateAdminMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, RemarkablesUpdateAdminMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, RemarkablesUpdateAdminMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateAdmin(msg, fee, memo, funds), options);
}
export interface RemarkablesUpdateRarityMintFeesMutation {
  client: RemarkablesClient;
  msg: {
    newFees: Coin[];
    rarityLevel: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useRemarkablesUpdateRarityMintFeesMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, RemarkablesUpdateRarityMintFeesMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, RemarkablesUpdateRarityMintFeesMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateRarityMintFees(msg, fee, memo, funds), options);
}
export interface RemarkablesMintMutation {
  client: RemarkablesClient;
  msg: {
    postId: Uint64;
    rarityLevel: number;
    remarkablesUri: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useRemarkablesMintMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, RemarkablesMintMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, RemarkablesMintMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.mint(msg, fee, memo, funds), options);
}